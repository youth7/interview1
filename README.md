#  题目分析

## 不严谨的地方

题目中描述：

> **随机**抽出一位中奖用户，要求积分越高中奖概率越高

从概率论的角度来说，*随机*一词意味着概率均等，即任何一位用户被抽中的可能是一样的，这和后面说的*要求积分越高中奖概率越高* 矛盾。所以我推测，题目要求的是设计一种算法，让具有某些特征的用户被抽中的概率更高，而不是真正地去随机去抽。

## 算法思路

* 将各个用户的积分当成一个子区间，子区间长度跟积分成正比（题目没有规定用户积分与概率之间的关系，这里假设它们是线性关系），
* 假设有$n$个用户，有$n$个子区间（$m_1,m_2...m_n$），将这个$n$个子区间首位相连形成一个大的区间$M$
* 在$M$上随机选取一个点，这个点必然在$m_1,m_2...m_n$上，易知此时落点服从均匀分布，即各个子区间被选中的概率跟长度成正比（证明略）。

![](http://processon.com/chart_image/5e60bc71e4b097b72752bbe2.png)

## 时间复杂度分析

因为只需要遍历若干次用户的积分以初始化程序，所以时间复杂度为$O(n)$



# 代码实现

完整代码见：https://github.com/youth7/interview1



# 一些遗留问题

当用户数量和积分都较大且用`Math.random()`生成的时候，用户获奖次数的概率整体上是和区间长度相关的，但是**最长的几个区间之间并不严格服从均匀分布**，这有两个可能：

* `Math.random()`的返回值不服从均匀分布
* 算法一些细节可能有问题

稍后再确认这个问题。

---

最后更新：从https://juejin.cn/post/6844903924512587783得知`Math.random()`是服从均匀分布的（从100万次测试结果的直方图看得出），但直方图的曲线在小范围内有一些小“尖刺”，意味着确实可能出现一些波动的数据，因此程序的运行结果是正常的。为了避免离群点的骚扰，在测试时候可以先拟合再进行判断。

# 时间消耗

| 内容         | 耗时   |
| ------------ | ------ |
| 算法设计     | 5分钟  |
| 编码和测试   | 35分钟 |
| 文档编写     | 20分钟 |
| 遗留问题调研 | 比较久 |





